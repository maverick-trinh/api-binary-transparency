var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _client, _secondarySlivers, _numShards, _blobBytes, _columnSize, _QuiltReader_instances, getSecondarySliver_fn, sliverator_fn, readBytesFromSlivers_fn, readBytesFromBlob_fn, readBytes_fn, readBlob_fn, getColumnSize_fn, getSizes_fn;
import { bcs } from "@mysten/bcs";
import { QuiltIndexV1, QuiltPatchBlobHeader, QuiltPatchId, QuiltPatchTags } from "../utils/bcs.js";
import { HAS_TAGS_FLAG, parseQuiltPatchId, QUILT_PATCH_BLOB_HEADER_SIZE } from "../utils/quilts.js";
import { getSourceSymbols, urlSafeBase64 } from "../utils/index.js";
class QuiltReader {
  constructor({ client, blobId, numShards, fullBlob }) {
    __privateAdd(this, _QuiltReader_instances);
    __privateAdd(this, _client);
    __privateAdd(this, _secondarySlivers, /* @__PURE__ */ new Map());
    __privateAdd(this, _numShards);
    __privateAdd(this, _blobBytes, null);
    __privateAdd(this, _columnSize, null);
    __privateSet(this, _client, client);
    this.blobId = blobId;
    __privateSet(this, _numShards, numShards);
    __privateSet(this, _blobBytes, fullBlob ?? null);
  }
  async getFullBlob() {
    if (!__privateGet(this, _blobBytes)) {
      __privateSet(this, _blobBytes, __privateGet(this, _client).readBlob({ blobId: this.blobId }));
    }
    return __privateGet(this, _blobBytes);
  }
  async readByPatchId(id) {
    const { quiltId, patchId } = parseQuiltPatchId(id);
    if (quiltId !== this.blobId) {
      throw new Error(`The requested patch ${patchId} is not part of the quilt ${this.blobId}`);
    }
    const sliverIndexes = [];
    for (let i = patchId.startIndex; i < patchId.endIndex; i++) {
      sliverIndexes.push(i);
    }
    if (sliverIndexes.length === 0) {
      throw new Error(`The requested patch ${patchId} is invalid`);
    }
    return __privateMethod(this, _QuiltReader_instances, readBlob_fn).call(this, sliverIndexes);
  }
  async readIndex() {
    const header = new DataView((await __privateMethod(this, _QuiltReader_instances, readBytes_fn).call(this, 0, 5)).buffer);
    const version = header.getUint8(0);
    if (version !== 1) {
      throw new Error(`Unsupported quilt version ${version}`);
    }
    const indexSize = header.getUint32(1, true);
    const indexBytes = await __privateMethod(this, _QuiltReader_instances, readBytes_fn).call(this, 0, indexSize, 5);
    const indexSlivers = Math.ceil(indexSize / await __privateMethod(this, _QuiltReader_instances, getColumnSize_fn).call(this));
    const index = QuiltIndexV1.parse(indexBytes);
    return index.patches.map((patch, i) => {
      const startIndex = i === 0 ? indexSlivers : index.patches[i - 1].endIndex;
      return {
        startIndex: i === 0 ? indexSlivers : index.patches[i - 1].endIndex,
        patchId: urlSafeBase64(
          QuiltPatchId.serialize({
            quiltId: this.blobId,
            patchId: {
              version: 1,
              startIndex,
              endIndex: patch.endIndex
            }
          }).toBytes()
        ),
        ...patch
      };
    });
  }
}
_client = new WeakMap();
_secondarySlivers = new WeakMap();
_numShards = new WeakMap();
_blobBytes = new WeakMap();
_columnSize = new WeakMap();
_QuiltReader_instances = new WeakSet();
getSecondarySliver_fn = async function({
  sliverIndex,
  signal
}) {
  if (__privateGet(this, _secondarySlivers).has(sliverIndex)) {
    return __privateGet(this, _secondarySlivers).get(sliverIndex);
  }
  const sliverPromise = __privateGet(this, _client).getSecondarySliver({
    blobId: this.blobId,
    index: sliverIndex,
    signal
  }).then((sliver) => new Uint8Array(sliver.symbols.data));
  __privateGet(this, _secondarySlivers).set(sliverIndex, sliverPromise);
  try {
    const sliver = await sliverPromise;
    __privateGet(this, _secondarySlivers).set(sliverIndex, sliver);
    return sliver;
  } catch (error) {
    __privateGet(this, _secondarySlivers).delete(sliverIndex);
    throw error;
  }
};
sliverator_fn = async function* (startIndex) {
  for (let i = startIndex; i < __privateGet(this, _numShards); i++) {
    yield __privateMethod(this, _QuiltReader_instances, getSecondarySliver_fn).call(this, { sliverIndex: i });
  }
};
readBytesFromSlivers_fn = async function(sliver, length, offset = 0, columnSize) {
  if (!length) {
    return new Uint8Array(0);
  }
  columnSize = columnSize ?? (await __privateMethod(this, _QuiltReader_instances, getSecondarySliver_fn).call(this, { sliverIndex: sliver })).length;
  const columnOffset = Math.floor(offset / columnSize);
  let remainingOffset = offset % columnSize;
  const slivers = __privateMethod(this, _QuiltReader_instances, sliverator_fn).call(this, sliver + columnOffset);
  const bytes = new Uint8Array(length);
  let bytesRead = 0;
  for await (const sliver2 of slivers) {
    let chunk = remainingOffset > 0 ? sliver2.subarray(remainingOffset) : sliver2;
    remainingOffset -= chunk.length;
    if (chunk.length > length - bytesRead) {
      chunk = chunk.subarray(0, length - bytesRead);
    }
    bytes.set(chunk, bytesRead);
    bytesRead += chunk.length;
    if (bytesRead === length) {
      break;
    }
  }
  return bytes;
};
readBytesFromBlob_fn = async function(startColumn, length, offset = 0) {
  const result = new Uint8Array(length);
  if (!length) {
    return result;
  }
  const blob = await this.getFullBlob();
  const { rowSize, symbolSize } = __privateMethod(this, _QuiltReader_instances, getSizes_fn).call(this, blob.length);
  const nRows = blob.length / rowSize;
  const symbolsToSkip = Math.floor(offset / symbolSize);
  let remainingOffset = offset % symbolSize;
  let currentCol = startColumn + Math.floor(symbolsToSkip / nRows);
  let currentRow = symbolsToSkip % nRows;
  let bytesRead = 0;
  while (bytesRead < length) {
    const baseIndex = currentRow * rowSize + currentCol * symbolSize;
    const startIndex = baseIndex + remainingOffset;
    const endIndex = Math.min(
      baseIndex + symbolSize,
      startIndex + length - bytesRead,
      blob.length
    );
    if (startIndex >= blob.length) {
      throw new Error("Index out of bounds");
    }
    const size = endIndex - startIndex;
    const subArray = blob.subarray(startIndex, endIndex);
    result.set(subArray, bytesRead);
    bytesRead += size;
    remainingOffset = 0;
    currentRow = (currentRow + 1) % nRows;
    if (currentRow === 0) {
      currentCol += 1;
    }
  }
  return result;
};
readBytes_fn = async function(sliver, length, offset = 0, columnSize) {
  if (__privateGet(this, _blobBytes)) {
    return __privateMethod(this, _QuiltReader_instances, readBytesFromBlob_fn).call(this, sliver, length, offset);
  }
  try {
    return await __privateMethod(this, _QuiltReader_instances, readBytesFromSlivers_fn).call(this, sliver, length, offset, columnSize);
  } catch (_error) {
    return __privateMethod(this, _QuiltReader_instances, readBytesFromBlob_fn).call(this, sliver, length, offset);
  }
};
readBlob_fn = async function(sliverIndexes) {
  const slivers = await Promise.all(
    sliverIndexes.map((sliverIndex) => __privateMethod(this, _QuiltReader_instances, getSecondarySliver_fn).call(this, { sliverIndex }))
  );
  const firstSliver = slivers[0];
  if (!firstSliver) {
    throw new Error("Cannot read blob from an empty set of slivers");
  }
  const blobHeader = QuiltPatchBlobHeader.parse(firstSliver);
  let offset = QUILT_PATCH_BLOB_HEADER_SIZE;
  let blobSize = blobHeader.length;
  const identifierLength = new DataView(firstSliver.buffer, offset, 2).getUint16(0, true);
  blobSize -= 2 + identifierLength;
  offset += 2;
  const identifier = bcs.string().parse(firstSliver.subarray(offset, offset + identifierLength));
  offset += identifierLength;
  let tags = null;
  if (blobHeader.mask & HAS_TAGS_FLAG) {
    const tagsSize = new DataView(firstSliver.buffer, offset, 2).getUint16(0, true);
    offset += 2;
    tags = QuiltPatchTags.parse(firstSliver.subarray(offset, offset + tagsSize));
    blobSize -= tagsSize + 2;
    offset += tagsSize;
  }
  const blobContents = await __privateMethod(this, _QuiltReader_instances, readBytes_fn).call(this, sliverIndexes[0], blobSize, offset, firstSliver.length);
  return {
    identifier,
    tags,
    blobContents
  };
};
getColumnSize_fn = async function() {
  if (__privateGet(this, _columnSize)) {
    return await __privateGet(this, _columnSize);
  }
  __privateSet(this, _columnSize, new Promise((resolve, reject) => {
    if (__privateGet(this, _blobBytes)) {
      Promise.resolve(__privateGet(this, _blobBytes)).then((bytes) => {
        const { rowSize, symbolSize } = __privateMethod(this, _QuiltReader_instances, getSizes_fn).call(this, bytes.length);
        return bytes.length / rowSize * symbolSize;
      }).then(resolve).catch(reject);
    }
    return __privateMethod(this, _QuiltReader_instances, getSecondarySliver_fn).call(this, { sliverIndex: 0 }).then((sliver) => resolve(sliver.length)).catch(reject);
  }).catch((error) => {
    __privateSet(this, _columnSize, null);
    throw error;
  }));
  return __privateGet(this, _columnSize);
};
getSizes_fn = function(encodedBlobSize) {
  const { primarySymbols, secondarySymbols } = getSourceSymbols(__privateGet(this, _numShards));
  const totalSymbols = primarySymbols * secondarySymbols;
  if (totalSymbols === 0) {
    throw new Error("symbol size should not be 0");
  }
  if (encodedBlobSize % totalSymbols !== 0) {
    throw new Error("blob length should be divisible by total symbols");
  }
  const symbolSize = encodedBlobSize / totalSymbols;
  const rowSize = symbolSize * secondarySymbols;
  return {
    symbolSize,
    rowSize
  };
};
export {
  QuiltReader
};
//# sourceMappingURL=reader.js.map
