{
  "version": 3,
  "sources": ["../../../src/quilt/reader.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '@mysten/bcs';\nimport { QuiltIndexV1, QuiltPatchBlobHeader, QuiltPatchId, QuiltPatchTags } from '../utils/bcs.js';\nimport { HAS_TAGS_FLAG, parseQuiltPatchId, QUILT_PATCH_BLOB_HEADER_SIZE } from '../utils/quilts.js';\nimport type { WalrusClient } from '../client.js';\nimport { getSourceSymbols, urlSafeBase64 } from '../utils/index.js';\n\nexport interface QuiltReaderOptions {\n\tclient: WalrusClient;\n\tblobId: string;\n\tnumShards: number;\n\tfullBlob?: Uint8Array;\n}\n\nexport class QuiltReader {\n\tblobId: string;\n\t#client: WalrusClient;\n\t#secondarySlivers = new Map<number, Uint8Array | Promise<Uint8Array>>();\n\t#numShards: number;\n\t#blobBytes: Uint8Array | Promise<Uint8Array> | null = null;\n\t#columnSize: number | Promise<number> | null = null;\n\n\tconstructor({ client, blobId, numShards, fullBlob }: QuiltReaderOptions) {\n\t\tthis.#client = client;\n\t\tthis.blobId = blobId;\n\t\tthis.#numShards = numShards;\n\t\tthis.#blobBytes = fullBlob ?? null;\n\t}\n\n\t// TODO: We should handle retries and epoch changes\n\tasync #getSecondarySliver({\n\t\tsliverIndex,\n\t\tsignal,\n\t}: {\n\t\tsliverIndex: number;\n\t\tsignal?: AbortSignal;\n\t}) {\n\t\tif (this.#secondarySlivers.has(sliverIndex)) {\n\t\t\treturn this.#secondarySlivers.get(sliverIndex)!;\n\t\t}\n\n\t\tconst sliverPromise = this.#client\n\t\t\t.getSecondarySliver({\n\t\t\t\tblobId: this.blobId,\n\t\t\t\tindex: sliverIndex,\n\t\t\t\tsignal,\n\t\t\t})\n\t\t\t.then((sliver) => new Uint8Array(sliver.symbols.data));\n\n\t\tthis.#secondarySlivers.set(sliverIndex, sliverPromise);\n\n\t\ttry {\n\t\t\tconst sliver = await sliverPromise;\n\t\t\tthis.#secondarySlivers.set(sliverIndex, sliver);\n\t\t\treturn sliver;\n\t\t} catch (error) {\n\t\t\tthis.#secondarySlivers.delete(sliverIndex);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync *#sliverator(startIndex: number) {\n\t\tfor (let i = startIndex; i < this.#numShards; i++) {\n\t\t\tyield this.#getSecondarySliver({ sliverIndex: i });\n\t\t}\n\t}\n\n\tasync #readBytesFromSlivers(sliver: number, length: number, offset = 0, columnSize?: number) {\n\t\tif (!length) {\n\t\t\treturn new Uint8Array(0);\n\t\t}\n\n\t\tcolumnSize = columnSize ?? (await this.#getSecondarySliver({ sliverIndex: sliver })).length;\n\t\tconst columnOffset = Math.floor(offset / columnSize);\n\t\tlet remainingOffset = offset % columnSize;\n\t\tconst slivers = this.#sliverator(sliver + columnOffset);\n\t\tconst bytes = new Uint8Array(length);\n\n\t\tlet bytesRead = 0;\n\n\t\tfor await (const sliver of slivers) {\n\t\t\tlet chunk = remainingOffset > 0 ? sliver.subarray(remainingOffset) : sliver;\n\t\t\tremainingOffset -= chunk.length;\n\t\t\tif (chunk.length > length - bytesRead) {\n\t\t\t\tchunk = chunk.subarray(0, length - bytesRead);\n\t\t\t}\n\n\t\t\tbytes.set(chunk, bytesRead);\n\t\t\tbytesRead += chunk.length;\n\n\t\t\tif (bytesRead === length) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn bytes;\n\t}\n\n\tasync #readBytesFromBlob(startColumn: number, length: number, offset = 0) {\n\t\tconst result = new Uint8Array(length);\n\n\t\tif (!length) {\n\t\t\treturn result;\n\t\t}\n\n\t\tconst blob = await this.getFullBlob();\n\t\tconst { rowSize, symbolSize } = this.#getSizes(blob.length);\n\n\t\tconst nRows = blob.length / rowSize;\n\t\tconst symbolsToSkip = Math.floor(offset / symbolSize);\n\t\tlet remainingOffset = offset % symbolSize;\n\t\tlet currentCol = startColumn + Math.floor(symbolsToSkip / nRows);\n\t\tlet currentRow = symbolsToSkip % nRows;\n\n\t\tlet bytesRead = 0;\n\n\t\twhile (bytesRead < length) {\n\t\t\tconst baseIndex = currentRow * rowSize + currentCol * symbolSize;\n\t\t\tconst startIndex = baseIndex + remainingOffset;\n\t\t\tconst endIndex = Math.min(\n\t\t\t\tbaseIndex + symbolSize,\n\t\t\t\tstartIndex + length - bytesRead,\n\t\t\t\tblob.length,\n\t\t\t);\n\n\t\t\tif (startIndex >= blob.length) {\n\t\t\t\tthrow new Error('Index out of bounds');\n\t\t\t}\n\n\t\t\tconst size = endIndex - startIndex;\n\t\t\tconst subArray = blob.subarray(startIndex, endIndex);\n\t\t\tresult.set(subArray, bytesRead);\n\t\t\tbytesRead += size;\n\n\t\t\tremainingOffset = 0;\n\n\t\t\tcurrentRow = (currentRow + 1) % nRows;\n\t\t\tif (currentRow === 0) {\n\t\t\t\tcurrentCol += 1;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tasync #readBytes(sliver: number, length: number, offset = 0, columnSize?: number) {\n\t\tif (this.#blobBytes) {\n\t\t\treturn this.#readBytesFromBlob(sliver, length, offset);\n\t\t}\n\n\t\ttry {\n\t\t\treturn await this.#readBytesFromSlivers(sliver, length, offset, columnSize);\n\t\t} catch (_error) {\n\t\t\t// fallback to reading the full blob\n\t\t\treturn this.#readBytesFromBlob(sliver, length, offset);\n\t\t}\n\t}\n\n\tasync getFullBlob() {\n\t\tif (!this.#blobBytes) {\n\t\t\tthis.#blobBytes = this.#client.readBlob({ blobId: this.blobId });\n\t\t}\n\n\t\treturn this.#blobBytes;\n\t}\n\n\tasync #readBlob(sliverIndexes: number[]) {\n\t\tconst slivers = await Promise.all(\n\t\t\tsliverIndexes.map((sliverIndex) => this.#getSecondarySliver({ sliverIndex })),\n\t\t);\n\n\t\tconst firstSliver = slivers[0];\n\n\t\tif (!firstSliver) {\n\t\t\tthrow new Error('Cannot read blob from an empty set of slivers');\n\t\t}\n\n\t\tconst blobHeader = QuiltPatchBlobHeader.parse(firstSliver);\n\n\t\tlet offset = QUILT_PATCH_BLOB_HEADER_SIZE;\n\t\tlet blobSize = blobHeader.length;\n\t\tconst identifierLength = new DataView(firstSliver.buffer, offset, 2).getUint16(0, true);\n\t\tblobSize -= 2 + identifierLength;\n\t\toffset += 2;\n\n\t\tconst identifier = bcs.string().parse(firstSliver.subarray(offset, offset + identifierLength));\n\n\t\toffset += identifierLength;\n\n\t\tlet tags: Record<string, string> | null = null;\n\t\tif (blobHeader.mask & HAS_TAGS_FLAG) {\n\t\t\tconst tagsSize = new DataView(firstSliver.buffer, offset, 2).getUint16(0, true);\n\t\t\toffset += 2;\n\n\t\t\ttags = QuiltPatchTags.parse(firstSliver.subarray(offset, offset + tagsSize));\n\t\t\tblobSize -= tagsSize + 2;\n\t\t\toffset += tagsSize;\n\t\t}\n\n\t\tconst blobContents = await this.#readBytes(\n\t\t\tsliverIndexes[0],\n\t\t\tblobSize,\n\t\t\toffset,\n\t\t\tfirstSliver.length,\n\t\t);\n\n\t\treturn {\n\t\t\tidentifier,\n\t\t\ttags,\n\t\t\tblobContents,\n\t\t};\n\t}\n\n\tasync readByPatchId(id: string) {\n\t\tconst { quiltId, patchId } = parseQuiltPatchId(id);\n\n\t\tif (quiltId !== this.blobId) {\n\t\t\tthrow new Error(`The requested patch ${patchId} is not part of the quilt ${this.blobId}`);\n\t\t}\n\n\t\tconst sliverIndexes = [];\n\n\t\tfor (let i = patchId.startIndex; i < patchId.endIndex; i++) {\n\t\t\tsliverIndexes.push(i);\n\t\t}\n\n\t\tif (sliverIndexes.length === 0) {\n\t\t\tthrow new Error(`The requested patch ${patchId} is invalid`);\n\t\t}\n\n\t\treturn this.#readBlob(sliverIndexes);\n\t}\n\n\tasync #getColumnSize() {\n\t\tif (this.#columnSize) {\n\t\t\treturn await this.#columnSize;\n\t\t}\n\n\t\tthis.#columnSize = new Promise<number>((resolve, reject) => {\n\t\t\tif (this.#blobBytes) {\n\t\t\t\tPromise.resolve(this.#blobBytes)\n\t\t\t\t\t.then((bytes) => {\n\t\t\t\t\t\tconst { rowSize, symbolSize } = this.#getSizes(bytes.length);\n\n\t\t\t\t\t\treturn (bytes.length / rowSize) * symbolSize;\n\t\t\t\t\t})\n\t\t\t\t\t.then(resolve)\n\t\t\t\t\t.catch(reject);\n\t\t\t}\n\n\t\t\treturn this.#getSecondarySliver({ sliverIndex: 0 })\n\t\t\t\t.then((sliver) => resolve(sliver.length))\n\t\t\t\t.catch(reject);\n\t\t}).catch((error) => {\n\t\t\tthis.#columnSize = null;\n\t\t\tthrow error;\n\t\t});\n\n\t\treturn this.#columnSize;\n\t}\n\n\t#getSizes(encodedBlobSize: number) {\n\t\tconst { primarySymbols, secondarySymbols } = getSourceSymbols(this.#numShards);\n\t\tconst totalSymbols = primarySymbols * secondarySymbols;\n\n\t\tif (totalSymbols === 0) {\n\t\t\tthrow new Error('symbol size should not be 0');\n\t\t}\n\n\t\tif (encodedBlobSize % totalSymbols !== 0) {\n\t\t\tthrow new Error('blob length should be divisible by total symbols');\n\t\t}\n\n\t\tconst symbolSize = encodedBlobSize / totalSymbols;\n\t\tconst rowSize = symbolSize * secondarySymbols;\n\n\t\treturn {\n\t\t\tsymbolSize,\n\t\t\trowSize,\n\t\t};\n\t}\n\n\tasync readIndex() {\n\t\tconst header = new DataView((await this.#readBytes(0, 5)).buffer);\n\n\t\tconst version = header.getUint8(0);\n\n\t\tif (version !== 1) {\n\t\t\tthrow new Error(`Unsupported quilt version ${version}`);\n\t\t}\n\n\t\tconst indexSize = header.getUint32(1, true);\n\t\tconst indexBytes = await this.#readBytes(0, indexSize, 5);\n\t\tconst indexSlivers = Math.ceil(indexSize / (await this.#getColumnSize()));\n\t\tconst index = QuiltIndexV1.parse(indexBytes);\n\n\t\treturn index.patches.map((patch, i) => {\n\t\t\tconst startIndex = i === 0 ? indexSlivers : index.patches[i - 1].endIndex;\n\n\t\t\treturn {\n\t\t\t\tstartIndex: i === 0 ? indexSlivers : index.patches[i - 1].endIndex,\n\t\t\t\tpatchId: urlSafeBase64(\n\t\t\t\t\tQuiltPatchId.serialize({\n\t\t\t\t\t\tquiltId: this.blobId,\n\t\t\t\t\t\tpatchId: {\n\t\t\t\t\t\t\tversion: 1,\n\t\t\t\t\t\t\tstartIndex,\n\t\t\t\t\t\t\tendIndex: patch.endIndex,\n\t\t\t\t\t\t},\n\t\t\t\t\t}).toBytes(),\n\t\t\t\t),\n\t\t\t\t...patch,\n\t\t\t};\n\t\t});\n\t}\n}\n"],
  "mappings": "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",
  "names": ["sliver"]
}
