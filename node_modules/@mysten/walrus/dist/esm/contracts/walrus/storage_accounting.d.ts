import type { Transaction } from '@mysten/sui/transactions';
import type { RawTransactionArgument } from '../utils/index.js';
export declare function FutureAccounting(): import("@mysten/sui/bcs").BcsType<{
    epoch: number;
    used_capacity: string;
    rewards_to_distribute: {
        value: string;
    };
}, {
    epoch: number;
    used_capacity: string | number | bigint;
    rewards_to_distribute: {
        value: string | number | bigint;
    };
}>;
export declare function FutureAccountingRingBuffer(): import("@mysten/sui/bcs").BcsType<{
    current_index: number;
    length: number;
    ring_buffer: {
        epoch: number;
        used_capacity: string;
        rewards_to_distribute: {
            value: string;
        };
    }[];
}, {
    current_index: number;
    length: number;
    ring_buffer: Iterable<{
        epoch: number;
        used_capacity: string | number | bigint;
        rewards_to_distribute: {
            value: string | number | bigint;
        };
    }> & {
        length: number;
    };
}>;
export interface MaxEpochsAheadArguments {
    self: RawTransactionArgument<string>;
}
export interface MaxEpochsAheadOptions {
    package?: string;
    arguments: MaxEpochsAheadArguments | [self: RawTransactionArgument<string>];
}
/** The maximum number of epochs for which we can use `self`. */
export declare function maxEpochsAhead(options: MaxEpochsAheadOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface RingLookupArguments {
    self: RawTransactionArgument<string>;
    epochsInFuture: RawTransactionArgument<number>;
}
export interface RingLookupOptions {
    package?: string;
    arguments: RingLookupArguments | [self: RawTransactionArgument<string>, epochsInFuture: RawTransactionArgument<number>];
}
/** Read-only lookup for an element in the `FutureAccountingRingBuffer` */
export declare function ringLookup(options: RingLookupOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface EpochArguments {
    accounting: RawTransactionArgument<string>;
}
export interface EpochOptions {
    package?: string;
    arguments: EpochArguments | [accounting: RawTransactionArgument<string>];
}
/** Accessor for epoch, read-only. */
export declare function epoch(options: EpochOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface UsedCapacityArguments {
    accounting: RawTransactionArgument<string>;
}
export interface UsedCapacityOptions {
    package?: string;
    arguments: UsedCapacityArguments | [accounting: RawTransactionArgument<string>];
}
/** Accessor for used_capacity, read-only. */
export declare function usedCapacity(options: UsedCapacityOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface RewardsArguments {
    accounting: RawTransactionArgument<string>;
}
export interface RewardsOptions {
    package?: string;
    arguments: RewardsArguments | [accounting: RawTransactionArgument<string>];
}
/** Accessor for rewards, read-only. */
export declare function rewards(options: RewardsOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
