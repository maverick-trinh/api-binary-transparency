import type { BcsType } from '@mysten/sui/bcs';
import type { Transaction } from '@mysten/sui/transactions';
import type { RawTransactionArgument } from '../utils/index.js';
/** Struct representing a priority queue. */
export declare function ApportionmentQueue<T extends BcsType<any>>(...typeParameters: [T]): BcsType<{
    entries: {
        priority: [string];
        tie_breaker: string;
        value: T extends BcsType<infer U, any> ? U : never;
    }[];
}, {
    entries: Iterable<{
        priority: readonly [string | number | bigint];
        tie_breaker: string | number | bigint;
        value: T extends BcsType<any, infer U_1> ? U_1 : never;
    }> & {
        length: number;
    };
}>;
export declare function Entry<T extends BcsType<any>>(...typeParameters: [T]): BcsType<{
    priority: [string];
    tie_breaker: string;
    value: T extends BcsType<infer U, any> ? U : never;
}, {
    priority: readonly [string | number | bigint];
    tie_breaker: string | number | bigint;
    value: T extends BcsType<any, infer U_1> ? U_1 : never;
}>;
export interface NewOptions {
    package?: string;
    arguments?: [];
    typeArguments: [string];
}
/** Create a new priority queue. */
export declare function _new(options: NewOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface PopMaxArguments {
    pq: RawTransactionArgument<string>;
}
export interface PopMaxOptions {
    package?: string;
    arguments: PopMaxArguments | [pq: RawTransactionArgument<string>];
    typeArguments: [string];
}
/** Pop the entry with the highest priority value. */
export declare function popMax(options: PopMaxOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface InsertArguments<T extends BcsType<any>> {
    pq: RawTransactionArgument<string>;
    priority: RawTransactionArgument<string>;
    tieBreaker: RawTransactionArgument<number | bigint>;
    value: RawTransactionArgument<T>;
}
export interface InsertOptions<T extends BcsType<any>> {
    package?: string;
    arguments: InsertArguments<T> | [
        pq: RawTransactionArgument<string>,
        priority: RawTransactionArgument<string>,
        tieBreaker: RawTransactionArgument<number | bigint>,
        value: RawTransactionArgument<T>
    ];
    typeArguments: [string];
}
/** Insert a new entry into the queue. */
export declare function insert<T extends BcsType<any>>(options: InsertOptions<T>): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
