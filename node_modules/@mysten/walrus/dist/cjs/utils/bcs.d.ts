import type { BcsType } from '@mysten/sui/bcs';
export declare const EncodingType: BcsType<import("@mysten/bcs").EnumOutputShapeWithKeys<{
    RedStuff: true;
    RS2: true;
}, "RedStuff" | "RS2">, "RedStuff" | "RS2" | {
    RedStuff: boolean | object | null;
} | {
    RS2: boolean | object | null;
}>;
export declare const BlobMetadataV1: BcsType<{
    encoding_type: import("@mysten/bcs").EnumOutputShapeWithKeys<{
        RedStuff: true;
        RS2: true;
    }, "RedStuff" | "RS2">;
    unencoded_length: string;
    hashes: {
        primary_hash: import("@mysten/bcs").EnumOutputShapeWithKeys<{
            Empty: true;
            Digest: Uint8Array<ArrayBufferLike>;
        }, "Empty" | "Digest">;
        secondary_hash: import("@mysten/bcs").EnumOutputShapeWithKeys<{
            Empty: true;
            Digest: Uint8Array<ArrayBufferLike>;
        }, "Empty" | "Digest">;
    }[];
}, {
    encoding_type: "RedStuff" | "RS2" | {
        RedStuff: boolean | object | null;
    } | {
        RS2: boolean | object | null;
    };
    unencoded_length: string | number | bigint;
    hashes: Iterable<{
        primary_hash: import("@mysten/bcs").EnumInputShape<{
            Empty: boolean | object | null;
            Digest: Iterable<number>;
        }>;
        secondary_hash: import("@mysten/bcs").EnumInputShape<{
            Empty: boolean | object | null;
            Digest: Iterable<number>;
        }>;
    }> & {
        length: number;
    };
}>;
export declare const BlobMetadata: BcsType<{
    V1: {
        encoding_type: import("@mysten/bcs").EnumOutputShapeWithKeys<{
            RedStuff: true;
            RS2: true;
        }, "RedStuff" | "RS2">;
        unencoded_length: string;
        hashes: {
            primary_hash: import("@mysten/bcs").EnumOutputShapeWithKeys<{
                Empty: true;
                Digest: Uint8Array<ArrayBufferLike>;
            }, "Empty" | "Digest">;
            secondary_hash: import("@mysten/bcs").EnumOutputShapeWithKeys<{
                Empty: true;
                Digest: Uint8Array<ArrayBufferLike>;
            }, "Empty" | "Digest">;
        }[];
    };
    $kind: "V1";
}, {
    V1: {
        encoding_type: "RedStuff" | "RS2" | {
            RedStuff: boolean | object | null;
        } | {
            RS2: boolean | object | null;
        };
        unencoded_length: string | number | bigint;
        hashes: Iterable<{
            primary_hash: import("@mysten/bcs").EnumInputShape<{
                Empty: boolean | object | null;
                Digest: Iterable<number>;
            }>;
            secondary_hash: import("@mysten/bcs").EnumInputShape<{
                Empty: boolean | object | null;
                Digest: Iterable<number>;
            }>;
        }> & {
            length: number;
        };
    };
}>;
export declare const BlobId: BcsType<string, string | bigint>;
export declare function blobIdFromInt(blobId: bigint | string): string;
export declare function blobIdFromBytes(blobId: Uint8Array): string;
export declare function blobIdToInt(blobId: string): bigint;
export declare const BlobMetadataWithId: BcsType<{
    blobId: string;
    metadata: {
        V1: {
            encoding_type: import("@mysten/bcs").EnumOutputShapeWithKeys<{
                RedStuff: true;
                RS2: true;
            }, "RedStuff" | "RS2">;
            unencoded_length: string;
            hashes: {
                primary_hash: import("@mysten/bcs").EnumOutputShapeWithKeys<{
                    Empty: true;
                    Digest: Uint8Array<ArrayBufferLike>;
                }, "Empty" | "Digest">;
                secondary_hash: import("@mysten/bcs").EnumOutputShapeWithKeys<{
                    Empty: true;
                    Digest: Uint8Array<ArrayBufferLike>;
                }, "Empty" | "Digest">;
            }[];
        };
        $kind: "V1";
    };
}, {
    blobId: string | bigint;
    metadata: {
        V1: {
            encoding_type: "RedStuff" | "RS2" | {
                RedStuff: boolean | object | null;
            } | {
                RS2: boolean | object | null;
            };
            unencoded_length: string | number | bigint;
            hashes: Iterable<{
                primary_hash: import("@mysten/bcs").EnumInputShape<{
                    Empty: boolean | object | null;
                    Digest: Iterable<number>;
                }>;
                secondary_hash: import("@mysten/bcs").EnumInputShape<{
                    Empty: boolean | object | null;
                    Digest: Iterable<number>;
                }>;
            }> & {
                length: number;
            };
        };
    };
}>;
export declare const SliverData: BcsType<{
    symbols: {
        data: number[];
        symbol_size: number;
    };
    index: number;
}, {
    symbols: {
        data: Iterable<number> & {
            length: number;
        };
        symbol_size: number;
    };
    index: number;
}>;
export declare const Sliver: BcsType<import("@mysten/bcs").EnumOutputShapeWithKeys<{
    Primary: {
        symbols: {
            data: number[];
            symbol_size: number;
        };
        index: number;
    };
    Secondary: {
        symbols: {
            data: number[];
            symbol_size: number;
        };
        index: number;
    };
}, "Primary" | "Secondary">, import("@mysten/bcs").EnumInputShape<{
    Primary: {
        symbols: {
            data: Iterable<number> & {
                length: number;
            };
            symbol_size: number;
        };
        index: number;
    };
    Secondary: {
        symbols: {
            data: Iterable<number> & {
                length: number;
            };
            symbol_size: number;
        };
        index: number;
    };
}>>;
export declare const SliverPair: BcsType<{
    primary: {
        symbols: {
            data: number[];
            symbol_size: number;
        };
        index: number;
    };
    secondary: {
        symbols: {
            data: number[];
            symbol_size: number;
        };
        index: number;
    };
}, {
    primary: {
        symbols: {
            data: Iterable<number> & {
                length: number;
            };
            symbol_size: number;
        };
        index: number;
    };
    secondary: {
        symbols: {
            data: Iterable<number> & {
                length: number;
            };
            symbol_size: number;
        };
        index: number;
    };
}>;
export declare enum IntentType {
    PROOF_OF_POSSESSION_MSG = 0,
    BLOB_CERT_MSG = 1,
    INVALID_BLOB_ID_MSG = 2,
    SYNC_SHARD_MSG = 3
}
export declare const Intent: BcsType<IntentType, IntentType>;
export declare function ProtocolMessage<T extends BcsType<any>>(messageContents: T): BcsType<{
    intent: IntentType;
    epoch: number;
    messageContents: T extends BcsType<infer U, any> ? U : never;
}, {
    intent: IntentType;
    epoch: number;
    messageContents: T extends BcsType<any, infer U_1> ? U_1 : never;
}>;
export declare const BlobPersistenceType: BcsType<import("@mysten/bcs").EnumOutputShapeWithKeys<{
    Permanent: true;
    Deletable: {
        objectId: string;
    };
}, "Permanent" | "Deletable">, import("@mysten/bcs").EnumInputShape<{
    Permanent: boolean | object | null;
    Deletable: {
        objectId: string | Uint8Array<ArrayBufferLike>;
    };
}>>;
export declare const StorageConfirmationBody: BcsType<{
    blobId: string;
    blobType: import("@mysten/bcs").EnumOutputShapeWithKeys<{
        Permanent: true;
        Deletable: {
            objectId: string;
        };
    }, "Permanent" | "Deletable">;
}, {
    blobId: string | bigint;
    blobType: import("@mysten/bcs").EnumInputShape<{
        Permanent: boolean | object | null;
        Deletable: {
            objectId: string | Uint8Array<ArrayBufferLike>;
        };
    }>;
}>;
export declare const StorageConfirmation: BcsType<{
    intent: IntentType;
    epoch: number;
    messageContents: {
        blobId: string;
        blobType: import("@mysten/bcs").EnumOutputShapeWithKeys<{
            Permanent: true;
            Deletable: {
                objectId: string;
            };
        }, "Permanent" | "Deletable">;
    };
}, {
    intent: IntentType;
    epoch: number;
    messageContents: {
        blobId: string | bigint;
        blobType: import("@mysten/bcs").EnumInputShape<{
            Permanent: boolean | object | null;
            Deletable: {
                objectId: string | Uint8Array<ArrayBufferLike>;
            };
        }>;
    };
}>;
export declare function Field<T0 extends BcsType<any>, T1 extends BcsType<any>>(...typeParameters: [T0, T1]): BcsType<{
    id: string;
    name: T0 extends BcsType<infer U, any> ? U : never;
    value: T1 extends BcsType<infer U, any> ? U : never;
}, {
    id: string | Uint8Array<ArrayBufferLike>;
    name: T0 extends BcsType<any, infer U_1> ? U_1 : never;
    value: T1 extends BcsType<any, infer U_1> ? U_1 : never;
}>;
export declare const QuiltPatchTags: BcsType<{
    [k: string]: string;
}, Map<string, string> | Record<string, string>>;
export declare const QuiltPatchV1: BcsType<{
    endIndex: number;
    identifier: string;
    tags: {
        [k: string]: string;
    };
}, {
    endIndex: number;
    identifier: string;
    tags: Map<string, string> | Record<string, string>;
}>;
export declare const QuiltIndexV1: BcsType<{
    patches: {
        endIndex: number;
        identifier: string;
        tags: {
            [k: string]: string;
        };
    }[];
}, {
    patches: Iterable<{
        endIndex: number;
        identifier: string;
        tags: Map<string, string> | Record<string, string>;
    }> & {
        length: number;
    };
}>;
export declare const QuiltPatchId: BcsType<{
    quiltId: string;
    patchId: {
        version: number;
        startIndex: number;
        endIndex: number;
    };
}, {
    quiltId: string | bigint;
    patchId: {
        version: number;
        startIndex: number;
        endIndex: number;
    };
}>;
export declare const QuiltPatchBlobHeader: BcsType<{
    version: number;
    length: number;
    mask: number;
}, {
    version: number;
    length: number;
    mask: number;
}>;
