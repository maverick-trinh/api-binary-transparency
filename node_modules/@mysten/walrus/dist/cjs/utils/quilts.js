"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var quilts_exports = {};
__export(quilts_exports, {
  BLOB_IDENTIFIER_SIZE_BYTES_LENGTH: () => BLOB_IDENTIFIER_SIZE_BYTES_LENGTH,
  HAS_TAGS_FLAG: () => HAS_TAGS_FLAG,
  MAX_BLOB_IDENTIFIER_BYTES_LENGTH: () => MAX_BLOB_IDENTIFIER_BYTES_LENGTH,
  MAX_NUM_SLIVERS_FOR_QUILT_INDEX: () => MAX_NUM_SLIVERS_FOR_QUILT_INDEX,
  QUILT_INDEX_PREFIX_SIZE: () => QUILT_INDEX_PREFIX_SIZE,
  QUILT_INDEX_SIZE_BYTES_LENGTH: () => QUILT_INDEX_SIZE_BYTES_LENGTH,
  QUILT_PATCH_BLOB_HEADER_SIZE: () => QUILT_PATCH_BLOB_HEADER_SIZE,
  QUILT_VERSION_BYTES_LENGTH: () => QUILT_VERSION_BYTES_LENGTH,
  TAGS_SIZE_BYTES_LENGTH: () => TAGS_SIZE_BYTES_LENGTH,
  computeSymbolSize: () => computeSymbolSize,
  parseQuiltPatchId: () => parseQuiltPatchId
});
module.exports = __toCommonJS(quilts_exports);
var import_bcs = require("./bcs.js");
var import_index = require("./index.js");
const QUILT_INDEX_SIZE_BYTES_LENGTH = 4;
const QUILT_VERSION_BYTES_LENGTH = 1;
const QUILT_INDEX_PREFIX_SIZE = QUILT_VERSION_BYTES_LENGTH + QUILT_INDEX_SIZE_BYTES_LENGTH;
const QUILT_PATCH_BLOB_HEADER_SIZE = 1 + 4 + 1;
const BLOB_IDENTIFIER_SIZE_BYTES_LENGTH = 2;
const TAGS_SIZE_BYTES_LENGTH = 2;
const MAX_BLOB_IDENTIFIER_BYTES_LENGTH = (1 << 8 * BLOB_IDENTIFIER_SIZE_BYTES_LENGTH) - 1;
const MAX_NUM_SLIVERS_FOR_QUILT_INDEX = 10;
const HAS_TAGS_FLAG = 1 << 0;
const REQUIRED_ALIGNMENT_BY_ENCODING_TYPE = {
  RS2: 2,
  RedStuff: 2
};
const MAX_SYMBOL_SIZE_BY_ENCODING_TYPE = {
  RS2: 2 ** 16 - 1,
  RedStuff: 2 ** 16 - 1
};
function computeSymbolSize(blobsSizes, nColumns, nRows, maxNumColumnsForQuiltIndex, encodingType = "RS2") {
  if (blobsSizes.length > nColumns) {
    throw new Error("Too many blobs, the number of blobs must be less than the number of columns");
  }
  if (blobsSizes.length === 0) {
    throw new Error("No blobs provided");
  }
  let minVal = Math.max(
    blobsSizes.reduce((acc, size) => acc + size, 0) / (nColumns * nRows),
    blobsSizes[0] / (nRows * maxNumColumnsForQuiltIndex),
    Math.ceil(QUILT_INDEX_PREFIX_SIZE / nRows)
  );
  let maxVal = Math.ceil(Math.max(...blobsSizes) / (nColumns / blobsSizes.length) * nRows);
  while (minVal < maxVal) {
    const mid = (minVal + maxVal) / 2;
    if (canBlobsFitIntoMatrix(blobsSizes, nColumns, mid * nRows)) {
      maxVal = mid;
    } else {
      minVal = mid + 1;
    }
  }
  const symbolSize = Math.ceil(minVal / REQUIRED_ALIGNMENT_BY_ENCODING_TYPE[encodingType]) * REQUIRED_ALIGNMENT_BY_ENCODING_TYPE[encodingType];
  if (!canBlobsFitIntoMatrix(blobsSizes, nColumns, symbolSize * nRows)) {
    throw new Error("Quilt oversize");
  }
  if (symbolSize > MAX_SYMBOL_SIZE_BY_ENCODING_TYPE[encodingType]) {
    throw new Error(
      `Quilt oversize: the resulting symbol size ${symbolSize} is larger than the maximum symbol size ${MAX_SYMBOL_SIZE_BY_ENCODING_TYPE[encodingType]}; remove some blobs`
    );
  }
  return symbolSize;
}
function canBlobsFitIntoMatrix(blobsSizes, nColumns, columnSize) {
  return blobsSizes.reduce((acc, size) => acc + Math.ceil(size / columnSize), 0) <= nColumns;
}
function parseQuiltPatchId(id) {
  return import_bcs.QuiltPatchId.parse((0, import_index.fromUrlSafeBase64)(id));
}
//# sourceMappingURL=quilts.js.map
