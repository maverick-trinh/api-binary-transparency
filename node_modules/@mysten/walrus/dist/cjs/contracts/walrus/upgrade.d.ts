import type { Transaction } from '@mysten/sui/transactions';
import type { RawTransactionArgument } from '../utils/index.js';
export declare function PackageDigest(): import("@mysten/sui/bcs").BcsType<[number[]], readonly [Iterable<number> & {
    length: number;
}]>;
export declare function UpgradeProposal(): import("@mysten/sui/bcs").BcsType<{
    epoch: number;
    digest: [number[]];
    version: string;
    voting_weight: number;
    voters: {
        contents: any[];
    };
}, {
    epoch: number;
    digest: readonly [Iterable<number> & {
        length: number;
    }];
    version: string | number | bigint;
    voting_weight: number;
    voters: {
        contents: Iterable<any> & {
            length: number;
        };
    };
}>;
export declare function UpgradeManager(): import("@mysten/sui/bcs").BcsType<{
    id: {
        id: string;
    };
    cap: {
        id: {
            id: string;
        };
        package: string;
        version: string;
        policy: number;
    };
    upgrade_proposals: {
        id: {
            id: string;
        };
        size: string;
    };
}, {
    id: {
        id: string | Uint8Array<ArrayBufferLike>;
    };
    cap: {
        id: {
            id: string | Uint8Array<ArrayBufferLike>;
        };
        package: string | Uint8Array<ArrayBufferLike>;
        version: string | number | bigint;
        policy: number;
    };
    upgrade_proposals: {
        id: {
            id: string | Uint8Array<ArrayBufferLike>;
        };
        size: string | number | bigint;
    };
}>;
export declare function EmergencyUpgradeCap(): import("@mysten/sui/bcs").BcsType<{
    id: {
        id: string;
    };
    upgrade_manager_id: string;
}, {
    id: {
        id: string | Uint8Array<ArrayBufferLike>;
    };
    upgrade_manager_id: string | Uint8Array<ArrayBufferLike>;
}>;
export interface VoteForUpgradeArguments {
    self: RawTransactionArgument<string>;
    staking: RawTransactionArgument<string>;
    auth: RawTransactionArgument<string>;
    nodeId: RawTransactionArgument<string>;
    digest: RawTransactionArgument<number[]>;
}
export interface VoteForUpgradeOptions {
    package?: string;
    arguments: VoteForUpgradeArguments | [
        self: RawTransactionArgument<string>,
        staking: RawTransactionArgument<string>,
        auth: RawTransactionArgument<string>,
        nodeId: RawTransactionArgument<string>,
        digest: RawTransactionArgument<number[]>
    ];
}
/**
 * Vote for an upgrade given the digest of the package to upgrade to.
 *
 * This will create a new upgrade proposal if none exists for the given digest.
 */
export declare function voteForUpgrade(options: VoteForUpgradeOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface AuthorizeUpgradeArguments {
    self: RawTransactionArgument<string>;
    staking: RawTransactionArgument<string>;
    digest: RawTransactionArgument<number[]>;
}
export interface AuthorizeUpgradeOptions {
    package?: string;
    arguments: AuthorizeUpgradeArguments | [
        self: RawTransactionArgument<string>,
        staking: RawTransactionArgument<string>,
        digest: RawTransactionArgument<number[]>
    ];
}
/** Authorizes an upgrade that has reached quorum. */
export declare function authorizeUpgrade(options: AuthorizeUpgradeOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface AuthorizeEmergencyUpgradeArguments {
    upgradeManager: RawTransactionArgument<string>;
    emergencyUpgradeCap: RawTransactionArgument<string>;
    digest: RawTransactionArgument<number[]>;
}
export interface AuthorizeEmergencyUpgradeOptions {
    package?: string;
    arguments: AuthorizeEmergencyUpgradeArguments | [
        upgradeManager: RawTransactionArgument<string>,
        emergencyUpgradeCap: RawTransactionArgument<string>,
        digest: RawTransactionArgument<number[]>
    ];
}
/**
 * Authorizes an upgrade using the emergency upgrade cap.
 *
 * This should be used sparingly and once walrus has a healthy community and
 * governance, the EmergencyUpgradeCap should be burned.
 */
export declare function authorizeEmergencyUpgrade(options: AuthorizeEmergencyUpgradeOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface CommitUpgradeArguments {
    upgradeManager: RawTransactionArgument<string>;
    staking: RawTransactionArgument<string>;
    system: RawTransactionArgument<string>;
    receipt: RawTransactionArgument<string>;
}
export interface CommitUpgradeOptions {
    package?: string;
    arguments: CommitUpgradeArguments | [
        upgradeManager: RawTransactionArgument<string>,
        staking: RawTransactionArgument<string>,
        system: RawTransactionArgument<string>,
        receipt: RawTransactionArgument<string>
    ];
}
/**
 * Commits an upgrade and sets the new package id in the staking and system
 * objects.
 *
 * After committing an upgrade, the staking and system objects should be migrated
 * using the [`package::migrate`] function to emit an event that informs all
 * storage nodes and prevent previous package versions from being used.
 */
export declare function commitUpgrade(options: CommitUpgradeOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface CleanupUpgradeProposalsArguments {
    self: RawTransactionArgument<string>;
    staking: RawTransactionArgument<string>;
    proposals: RawTransactionArgument<number[][]>;
}
export interface CleanupUpgradeProposalsOptions {
    package?: string;
    arguments: CleanupUpgradeProposalsArguments | [
        self: RawTransactionArgument<string>,
        staking: RawTransactionArgument<string>,
        proposals: RawTransactionArgument<number[][]>
    ];
}
/**
 * Cleans up the upgrade proposals table.
 *
 * Deletes all proposals from past epochs and versions that are lower than the
 * current version.
 */
export declare function cleanupUpgradeProposals(options: CleanupUpgradeProposalsOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface BurnEmergencyUpgradeCapArguments {
    emergencyUpgradeCap: RawTransactionArgument<string>;
}
export interface BurnEmergencyUpgradeCapOptions {
    package?: string;
    arguments: BurnEmergencyUpgradeCapArguments | [emergencyUpgradeCap: RawTransactionArgument<string>];
}
/**
 * Burns the emergency upgrade cap.
 *
 * This will prevent any further upgrades using the `EmergencyUpgradeCap` and will
 * make upgrades fully reliant on quorum-based governance.
 */
export declare function burnEmergencyUpgradeCap(options: BurnEmergencyUpgradeCapOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
